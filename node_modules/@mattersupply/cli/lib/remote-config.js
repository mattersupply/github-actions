"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const aws_1 = require("./aws");
const js_yaml_1 = require("js-yaml");
var RemoteConfigurationPath;
(function (RemoteConfigurationPath) {
    function namespace(stage, config) {
        return `/${config === null || config === void 0 ? void 0 : config.get('app.name')}/${stage}/`;
    }
    RemoteConfigurationPath.namespace = namespace;
    function pathFromKey(key, stage, config) {
        return `${namespace(stage, config)}${lodash_1.kebabCase(key)}`;
    }
    RemoteConfigurationPath.pathFromKey = pathFromKey;
    function keyFromPath(path, stage, config) {
        return path.replace(namespace(stage, config), '');
    }
    RemoteConfigurationPath.keyFromPath = keyFromPath;
    function dotenvKeyFromPath(path, stage, config) {
        const key = keyFromPath(path, stage, config);
        return lodash_1.toUpper(lodash_1.snakeCase(key));
    }
    RemoteConfigurationPath.dotenvKeyFromPath = dotenvKeyFromPath;
})(RemoteConfigurationPath = exports.RemoteConfigurationPath || (exports.RemoteConfigurationPath = {}));
var RemoteConfigurationFormatter;
(function (RemoteConfigurationFormatter) {
    function dotenv(values) {
        let output = '';
        Object.entries(values).map(([key, parameter]) => {
            if (!parameter.Name) {
                return;
            }
            const value = parameter.Value;
            output += `# Type: ${parameter.Type}, Version: ${parameter.Version}, Key: ${parameter.Name}\n`;
            output += `${lodash_1.toUpper(lodash_1.snakeCase(key))}=${value}\n`;
        });
        return output;
    }
    RemoteConfigurationFormatter.dotenv = dotenv;
    function yaml(values) {
        return js_yaml_1.safeDump(values);
    }
    RemoteConfigurationFormatter.yaml = yaml;
})(RemoteConfigurationFormatter = exports.RemoteConfigurationFormatter || (exports.RemoteConfigurationFormatter = {}));
async function fetchValues(stages, cfg) {
    const fetchedParameters = await Promise.all(stages.map(async (stage) => ({ stage, values: await fetchValuesByStage(stage, cfg) })));
    const parameters = fetchedParameters.reduce((acc, value) => {
        acc[value.stage] = value.values;
        return acc;
    }, {});
    return parameters;
}
exports.fetchValues = fetchValues;
async function fetchValuesByStage(stage, cfg) {
    const namespace = RemoteConfigurationPath.namespace(stage, cfg);
    const ssm = aws_1.createSSMConfigManager(cfg);
    let parameterValues = await ssm
        .getParametersByPath({
        Path: namespace,
    })
        .promise();
    let nextToken = parameterValues.NextToken;
    while (nextToken) {
        const pagedResult = await ssm
            .getParametersByPath({
            Path: namespace,
            NextToken: nextToken,
        })
            .promise();
        nextToken = pagedResult.NextToken;
        parameterValues = Object.assign(Object.assign({}, parameterValues), { Parameters: [...(pagedResult.Parameters || []), ...(parameterValues.Parameters || [])] });
    }
    return parameterValues;
}
exports.fetchValuesByStage = fetchValuesByStage;
function combineValues(valuesByStage, cfg) {
    // Reduce over all stages
    const keyedDescriptions = Object.keys(valuesByStage).map((stage) => {
        return descriptionsByKey(valuesByStage[stage].Parameters || [], stage, cfg);
    });
    const merged = lodash_1.defaults(keyedDescriptions[0], ...keyedDescriptions);
    return merged;
}
exports.combineValues = combineValues;
function descriptionsByKey(parameters, stage, cfg) {
    return parameters === null || parameters === void 0 ? void 0 : parameters.reduce((parameters, param) => {
        if (!param.Name) {
            throw new Error(`Parameter without a name found.`);
        }
        parameters[RemoteConfigurationPath.keyFromPath(param.Name, stage, cfg)] = param;
        return parameters;
    }, {});
}
exports.descriptionsByKey = descriptionsByKey;
